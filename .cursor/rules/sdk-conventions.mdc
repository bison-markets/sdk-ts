---
description: function call signatures, deciding when to use number/bigint/bigint strings/fixed-point strings
alwaysApply: false
---
# SDK String Format Conventions

This SDK follows the Bison API's string-based bigint conventions for all monetary amounts and contract quantities.

## Request Format (SDK → API)

When calling SDK methods, use these formats:

| Parameter Type | Format | Example | Description |
|---------------|--------|---------|-------------|
| Contract quantity (`number`) | **Fixed-point string** | `"10.50"` | Human-readable format with decimals |
| µUSDC amount (`priceUusdc`, `amountUusdc`) | **Integer string** | `"750000"` | Micro-USDC (1 USDC = 1,000,000 µUSDC) |

### Examples

```typescript
// Place an order for 10.5 contracts at $0.75 each
await client.placeOrder({
  marketId: 'PRES-2024',
  number: '10.50',        // Fixed-point string
  priceUusdc: '750000',   // Integer string (0.75 * 1,000,000)
  action: 'buy',
  side: 'yes',
  // ...
});

// Mint 5 position tokens
await client.executeMintFlow({
  marketId: 'PRES-2024',
  number: '5',            // Fixed-point string (can omit .00)
  side: 'yes',
  // ...
});

// Deposit 10 USDC
await client.executeDepositFlow({
  amountUusdc: '10000000', // Integer string (10 * 1,000,000)
  // ...
});
```

## Response Format (API → SDK)

API responses contain **integer strings** (scaled values) for all bigint fields:

```typescript
// Order response
{
  requestedQuantity: '1050',  // Scaled value (10.50 * 100 for precision 2)
  priceUusdc: '750000',       // µUSDC value
}

// Position response
{
  quantity: '1050',           // Scaled value
}
```

The SDK automatically converts these to `bigint` for convenient TypeScript usage via `parseBigIntFields()`.

## Conversion Utilities

For advanced use cases, conversion utilities are exported:

```typescript
import { 
  fixedPointToQuantity, 
  quantityToFixedPoint,
  usdcToUusdc,
  uusdcToUsdc,
} from '@bison-markets/sdk-ts';

// Convert fixed-point to scaled quantity
const scaled = fixedPointToQuantity('10.50', 2); // 1050n

// Convert scaled quantity back to fixed-point
const display = quantityToFixedPoint(1050n, 2); // '10.50'

// Convert USDC to µUSDC
const microUsdc = usdcToUusdc('1.5'); // 1500000n

// Convert µUSDC to USDC
const usdc = uusdcToUsdc(1500000n); // '1.500000'
```

## Why These Conventions?

**Fixed-point strings for input:**
- Human-readable and intuitive
- Matches user expectations (e.g., "I want 10.5 contracts")
- API validates precision against market requirements

**Integer strings for output:**
- Represents true internal scaled values
- Avoids floating-point precision issues
- Clients can format based on their needs

**Strings over numbers:**
- JavaScript `number` type limited to 53-bit precision
- Prevents precision loss for large values
- Consistent with blockchain conventions (uint256)
