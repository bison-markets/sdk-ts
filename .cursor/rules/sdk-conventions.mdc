---
description: function call signatures, deciding when to use number/bigint/bigint strings/fixed-point strings
alwaysApply: false
---
# SDK String Format Conventions

This SDK follows the Bison API's string-based bigint conventions for all monetary amounts and contract quantities.

## Request Format (SDK → API)

When calling SDK methods, use these formats:

| Parameter Type | Format | Example | Description |
|---------------|--------|---------|-------------|
| Contract quantity (`ccontracts`) | **Integer string** | `"1050"` | Internal units (1 contract = 100 ccontracts) |
| µUSDC amount (`priceUusdc`, `amountUusdc`) | **Integer string** | `"750000"` | Micro-USDC (1 USDC = 1,000,000 µUSDC) |

### Examples

```typescript
// Place an order for 10.5 contracts (1050 ccontracts) at $0.75 each
await client.placeOrder({
  marketId: 'PRES-2024',
  ccontracts: '1050',     // Integer string (10.5 * 100)
  priceUusdc: '750000',   // Integer string (0.75 * 1,000,000)
  action: 'buy',
  side: 'yes',
  // ...
});

// Mint 5 contracts (500 ccontracts)
await client.executeMintFlow({
  marketId: 'PRES-2024',
  ccontracts: '500',      // Integer string (5 * 100)
  side: 'yes',
  // ...
});

// Deposit 10 USDC
await client.executeDepositFlow({
  amountUusdc: '10000000', // Integer string (10 * 1,000,000)
  // ...
});
```

## Response Format (API → SDK)

API responses contain **integer strings** (scaled values) for all bigint fields:

```typescript
// Order response
{
  requestedCcontracts: '1050',  // Scaled value (10.50 * 100 for precision 2)
  priceUusdc: '750000',       // µUSDC value
}

// Position response
{
  ccontracts: '1050',         // Scaled value
}
```

The SDK automatically converts these to `bigint` for convenient TypeScript usage via `parseBigIntFields()`.

## Conversion Utilities

For advanced use cases, conversion utilities are exported:

```typescript
import {
  contractsToCcontracts,
  ccontractsToContracts,
  usdcToUusdc,
  uusdcToUsdc,
} from '@bison-markets/sdk-ts';

// Convert fixed-point to scaled quantity
const scaled = contractsToCcontracts('10.50', 2); // 1050n

// Convert scaled quantity back to fixed-point
const display = ccontractsToContracts(1050n, 2); // '10.50'

// Convert USDC to µUSDC
const microUsdc = usdcToUusdc('1.5'); // 1500000n

// Convert µUSDC to USDC
const usdc = uusdcToUsdc(1500000n); // '1.500000'
```

## Why These Conventions?

**Integer strings for input:**
- Unambiguous scaled quantities
- Matches API expectations for contract and µUSDC amounts
- Avoids fixed-point parsing at API boundaries

**Integer strings for output:**
- Represents true internal scaled values
- Avoids floating-point precision issues
- Clients can format based on their needs

**Strings over numbers:**
- JavaScript `number` type limited to 53-bit precision
- Prevents precision loss for large values
- Consistent with blockchain conventions (uint256)
